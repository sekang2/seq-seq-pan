import sys

sys.setrecursionlimit(1000000)

SCRIPT="python3 " + srcdir("supergenome.py")
JAR="java -jar " + srcdir("java/XMFAConsensus/XMFAconsensus_majorityvote.jar")

with open(config["genomefile"], "r") as f:
    GENOMES = f.readlines()

GENOME_DICT = {str(idx): {"name": GENOMES[idx].split(";")[1].strip(), "file":GENOMES[idx].split(";")[0].strip()} for idx in range(len(GENOMES))}
GENOME_NAMES = [str(idx) for idx in range(len(GENOMES))]
MERGE = config.get("merge", "")
UNAMBIGUOUS = config.get("unambiguous", "")
if MERGE.lower() == "true":
    MERGE = True
else:
    MERGE = False


if UNAMBIGUOUS.lower() == "true":
    UNAMBIGUOUS = True
else:
    UNAMBIGUOUS = False    
    
    
# resolving not possible/necessary for alignment of first two genomes
def resolve_or_not(wildcards):
    return("add"+wildcards["genome"]+"_resolve.xmfa" if int(wildcards["genome"]) > 1 else "add"+wildcards["genome"]+"_realign.xmfa")

# merge after alignment
def merge_or_not(wildcards):
    return("add"+wildcards["genome"]+"_merge.xmfa" if MERGE else "add"+wildcards["genome"]+".xmfa")
    
def merge_or_not_param(wildcards):
    return ("-m" if MERGE else "")
    

def mauve_input(wildcards):
    
    return (GENOME_DICT[wildcards["genome"]]["file"])
    
    
def consensus_file(wildcards):
    
    newnr = prev_genome(wildcards)
    
    if newnr == "0":
        consgen = [GENOME_DICT[newnr]["file"]]
    else:
        consgen = ["add"+newnr+"_consensus.fasta.blockseparated.fasta", "add"+newnr+"_consensus.fasta", "add"+newnr+"_consensus.fasta.blockseparated.idx"]
        
    return consgen


def prev_genome(wildcards):
    return(str(int(wildcards['genome']) - 1))
    
    
rule all:
    input:  config["outfilename"]+"_consensus.fasta.blockseparated.fasta",
            config["outfilename"]+"_consensus.fasta.blockseparated.idx",
            config["outfilename"]+"_consensus.fasta.idx",
            config["outfilename"]+"_consensus.fasta",
            config["outfilename"]+"_resolve.xmfa",
            config["outfilename"]+"_resolve.maf"
    
rule fn_translate:
    input:  cb = "add"+str(len(GENOME_NAMES)-1)+"_consensus.fasta.blockseparated.fasta",
            cbi = "add"+str(len(GENOME_NAMES)-1)+"_consensus.fasta.blockseparated.idx",
            ci = "add"+str(len(GENOME_NAMES)-1)+"_consensus.fasta.idx",
            c = "add"+str(len(GENOME_NAMES)-1)+"_consensus.fasta",
            xmfa = "add"+str(len(GENOME_NAMES)-1)+"_resolve.xmfa"
            
    output: cb = config["outfilename"]+"_consensus.fasta.blockseparated.fasta",
            cbi = config["outfilename"]+"_consensus.fasta.blockseparated.idx",
            ci = config["outfilename"]+"_consensus.fasta.idx",
            c = config["outfilename"]+"_consensus.fasta",
            xmfa = config["outfilename"]+"_resolve.xmfa"
            
    shell:
        '''
        name={input.c}
        out={output.c}
        name="${{name//_consensus.fasta}}"
        out="${{out//_consensus.fasta}}"
        cp {input.cb} {output.cb}
        cp {input.cbi} {output.cbi}
        cp {input.ci} {output.ci}
        cp {input.c} {output.c}
        cp {input.xmfa} {output.xmfa}
        
        sed -i "1 s/$name/$out/g" {output.c}
        sed -i "1 s/$name/$out/g" {output.cb}
        sed -i "1 s/$name/$out/" {output.ci}
        sed -i "2 s/$name/$out/" {output.ci}
        sed -i "1 s/$name/$out/" {output.cbi}
        sed -i "2 s/$name/$out/" {output.cbi}
        '''

        
rule consensus:
    input: resolve_or_not
    
    output: temp("add{genome}_consensus.fasta.blockseparated.fasta"),
            temp("add{genome}_consensus.fasta.blockseparated.idx"),
            temp("add{genome}_consensus.fasta.idx"),
            temp("add{genome}_consensus.fasta")
    #params: u= UNAMBIGUOUS 
    run:
        if UNAMBIGUOUS:
            shell("{SCRIPT} -x {input} -p . -n add{wildcards.genome} -t consensus -u")
        else:
            shell("{JAR} --xmfa {input} --outfasta {output[3]} --outidx {output[2]} --outblocksepfasta {output[0]} --outblocksepidx {output[1]}")

rule resolve:
    input:  xmfa_prev= lambda wildcards: resolve_or_not({"genome":prev_genome(wildcards)}), 
            xmfa= "add{genome}_realign.xmfa", 
            consensus=consensus_file
    output: temp("add{genome,\d+}_resolve.xmfa")
    params: merge=merge_or_not_param
    shell:
        "{SCRIPT} -x {input.xmfa} -p . -n add{wildcards.genome} -t resolve -c {input.consensus[1]} {params.merge}"
        
        
rule realign:
    input: merge_or_not
    output: temp("add{genome,\d+}_realign.xmfa")
    shell:
        "{SCRIPT} -x {input} -p . -n add{wildcards.genome} -t realign"

        
rule merge:
    input: "add{genome}.xmfa"
    output: temp("add{genome,\d+}_merge.xmfa")
    shell:
        "{SCRIPT} -x {input} -p . -n add{wildcards.genome} -t merge"        
        
        
rule align:
    input:  consensus=consensus_file, 
            new=mauve_input
    output: temp("add{genome, \d+}.xmfa"), 
            temp("add{genome, \d+}.xmfa.bbcols"), 
            temp("add{genome, \d+}.xmfa.backbone")
    shell:
        '''
        input=`basename {input.consensus[0]}`
        input2=`basename {input.new}`
        
        input=temp_$input
        input2=temp_$input2
        
        cp {input.consensus[0]} $input
        cp {input.new} $input2
        
        progressiveMauve $input $input2 --output={output[0]} --max-gapped-aligner-length=900 > /dev/null
        
        sed -i "s|$input|{input.consensus[0]}|g" {output[0]}
        sed -i "s|$input2|{input.new}|g" {output[0]}
        
        rm $input.sslist
        rm $input
        rm $input2.sslist
        rm $input2
        '''
        
        
rule maf:
    input: "{genome}.xmfa"
    output: "{genome}.maf"
    shell:
        "{SCRIPT} -x {input} -p . -n {wildcards.genome} -t maf"
