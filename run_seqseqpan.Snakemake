import sys
import re

sys.setrecursionlimit(1000000)

SCRIPT="python3 " + srcdir("seqseqpan.py")
JAR="java -jar " + srcdir("java/XMFAConsensus/XMFAconsensus_majorityvote.jar")
GENOMEDESC_SCRIPT= "python3 " + srcdir("genomedescription.py")

with open(config["genomefile"], "r") as f:
    GENOMES = f.readlines()

GENOME_DICT = {str(idx): GENOMES[idx].strip() for idx in range(len(GENOMES))}
GENOME_NAMES = [str(idx) for idx in range(len(GENOMES))]
MERGE = config.get("merge", "")
PREV_PAN = config.get("pangenome", "")

if MERGE.lower() == "false":
    MERGE = False
else:
    MERGE = True

if PREV_PAN != "":
     PREV_PAN = re.sub("\.xmfa$", "", PREV_PAN)
    

ruleorder: use_prev_pan > resolve


# determine which file is translated to output xmfa
def output_xmfa(wildcards):
    xmfa_f = resolve_or_not({"genome": str(len(GENOME_NAMES)-1)})
    return xmfa_f

# resolving not possible/necessary for alignment of first two genomes
def resolve_or_not(wildcards):
    return ("add"+wildcards["genome"]+"_realign.xmfa"  if (int(wildcards["genome"]) <= 1 and PREV_PAN == "" ) else "add"+wildcards["genome"]+"_resolve.xmfa")

# merge after alignment
def merge_or_not(wildcards):
    return("add"+wildcards["genome"]+"_merge.xmfa" if MERGE else "add"+wildcards["genome"]+"_align.xmfa")
    
def merge_or_not_param(wildcards):
    return ("-m" if MERGE else "")

def prev_pan_or_not_param(wildcards):
    return ("-a "+ PREV_PAN +"_genomedescription.txt" if PREV_PAN != "" else "")

def mauve_input(wildcards):
    return (GENOME_DICT[wildcards["genome"]])

def consensus_file(wildcards):

    new_nr = prev_genome(wildcards)

    if int(new_nr) > 0 or (int(new_nr) <= 0 and PREV_PAN != ""):
       consgen = ["add"+new_nr+"_consensus.fasta.blockseparated.fasta", "add"+new_nr+"_consensus.fasta", "add"+new_nr+"_consensus.fasta.blockseparated.idx"]
    elif PREV_PAN == "":
       consgen = [GENOME_DICT[new_nr]]
    else:
        print("Error in defining the second file for alignment.")

    return consgen

def prev_genome(wildcards):
    return(str(int(wildcards['genome']) - 1))



rule all:
    input:  config["outfilename"]+"_genomedescription.txt",
            config["outfilename"]+"_consensus.fasta.blockseparated.fasta",
            config["outfilename"]+"_consensus.fasta.blockseparated.idx",
            config["outfilename"]+"_consensus.fasta.idx",
            config["outfilename"]+"_consensus.fasta",
            config["outfilename"]+".xmfa",
            config["outfilename"]+".maf"
    
rule fn_translate:
    input:  cb = "add"+str(len(GENOME_NAMES)-1)+"_consensus.fasta.blockseparated.fasta",
            cbi = "add"+str(len(GENOME_NAMES)-1)+"_consensus.fasta.blockseparated.idx",
            ci = "add"+str(len(GENOME_NAMES)-1)+"_consensus.fasta.idx",
            c = "add"+str(len(GENOME_NAMES)-1)+"_consensus.fasta",
            xmfa = output_xmfa
            
    output: cb = config["outfilename"]+"_consensus.fasta.blockseparated.fasta",
            cbi = config["outfilename"]+"_consensus.fasta.blockseparated.idx",
            ci = config["outfilename"]+"_consensus.fasta.idx",
            c = config["outfilename"]+"_consensus.fasta",
            xmfa = config["outfilename"]+".xmfa"
            
    shell:
        '''
        name={input.c}
        out={output.c}
        name="${{name//_consensus.fasta}}"
        out="${{out//_consensus.fasta}}"
        cp {input.cb} {output.cb}
        cp {input.cbi} {output.cbi}
        cp {input.ci} {output.ci}
        cp {input.c} {output.c}
        cp {input.xmfa} {output.xmfa}
        
        sed -i "1 s/$name/$out/g" {output.c}
        sed -i "1 s/$name/$out/g" {output.cb}
        sed -i "1 s/$name/$out/" {output.ci}
        sed -i "2 s/$name/$out/" {output.ci}
        sed -i "1 s/$name/$out/" {output.cbi}
        sed -i "2 s/$name/$out/" {output.cbi}
        '''

        
rule consensus:
    input: resolve_or_not
    
    output: temp("add{genome}_consensus.fasta.blockseparated.fasta"),
            temp("add{genome}_consensus.fasta.blockseparated.idx"),
            temp("add{genome}_consensus.fasta.idx"),
            temp("add{genome}_consensus.fasta")
    shell:
        #"{SCRIPT} -x {input} -p . -n add{wildcards.genome} -t consensus"
        "{JAR} --xmfa {input} --outfasta {output[3]} --outidx {output[2]} --outblocksepfasta {output[0]} --outblocksepidx {output[1]}"


rule resolve:
    input:  xmfa_prev= lambda wildcards: resolve_or_not({"genome":prev_genome(wildcards)}), 
            xmfa= "add{genome}_realign.xmfa", 
            consensus=consensus_file
    output: temp("add{genome,\d+}_resolve.xmfa")
    params: merge=merge_or_not_param
    shell:
        "{SCRIPT} -x {input.xmfa} -p . -n add{wildcards.genome} -t resolve -c {input.consensus[1]} {params.merge}"
        
        
rule realign:
    input: merge_or_not
    output: temp("add{genome,\d+}_realign.xmfa")
    shell:
        "{SCRIPT} -x {input} -p . -n add{wildcards.genome} -t realign"

        
rule merge:
    input: "add{genome}_align.xmfa"
    output: temp("add{genome,\d+}_merge.xmfa")
    shell:
        "{SCRIPT} -x {input} -p . -n add{wildcards.genome} -t merge"        
        
        
rule align:
    input:  consensus=consensus_file, 
            new=mauve_input
    output: temp("add{genome, \d+}_align.xmfa"),
            temp("add{genome, \d+}_align.xmfa.bbcols"),
            temp("add{genome, \d+}_align.xmfa.backbone")
    shell:
        '''
        input=`basename {input.consensus[0]}`
        input2=`basename {input.new}`
        
        input=temp_$input
        input2=temp_$input2
        
        cp {input.consensus[0]} $input
        cp {input.new} $input2
        
        progressiveMauve $input $input2 --output={output[0]} > /dev/null
        
        sed -i "s|$input|{input.consensus[0]}|g" {output[0]}
        sed -i "s|$input2|{input.new}|g" {output[0]}
        
        rm $input.sslist
        rm $input
        rm $input2.sslist
        rm $input2
        '''
        
        
rule maf:
    input: xmfa="{genome}.xmfa",
           genomedesc=config["outfilename"]+"_genomedescription.txt"
    output: "{genome}.maf"
    shell:
        "{SCRIPT} -x {input.xmfa} -p . -n {wildcards.genome} -t maf -g {input.genomedesc}"


rule split:
    input: xmfa="add{genome}_resolve.xmfa",
           genomedesc=config["outfilename"]+"_genomedescription.txt"
    output: "add{genome}_split.xmfa"
    shell:
        "{SCRIPT} -x {input.genome} -p . -n add{wildcards.genome} -t split -g {input.genomedesc}"


rule genomedesc:
    input: config["genomefile"]
    output: config["outfilename"]+"_genomedescription.txt"
    params: add=prev_pan_or_not_param
    shell:
        "{GENOMEDESC_SCRIPT} -i {input} -o {output} {params.add}"


rule use_prev_pan:
    input: PREV_PAN+".xmfa"
    output: temp("add-1_resolve.xmfa")
    shell:
        "cp {input} {output} "